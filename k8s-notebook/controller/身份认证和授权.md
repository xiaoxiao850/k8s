# 身份认证和授权

## 认证

kube-apiserver支持多种认证机制，并支持同时开启多个认证功能。当客户端发起一个请求，经过认证阶段时，只要有一个认证器通过，则认证成功。

### 9种认证机制

kube-apiserver目前提供了9种认证机制，分别是BasicAuth、ClientCA、TokenAuth、BootstrapToken、RequestHeader、WebhookTokenAuth、Anonymous、OIDC、ServiceAccountAuth。

- BasicAuth：客户端将用户、密码写入请求头中（key为Authorization，value为`Basic BASE64ENCODED（USER：PASSWORD）`，其中用户名及密码是通过Base64编码后的字符串）

  ```
  指定--basic-auth-file参数启用BasicAuth认证。
  AUTH_FILE是一个CSV文件，每个用户在CSV中的表现形式为password、username、uid
  ```

  

- ClientCA：也被称为TLS双向认证，即服务端与客户端互相验证证书的正确性。CA签名过的证书都可以通过验证。

  ```
  指定--client-ca-file参数启用ClientCA认证。
  ```

  

- TokenAuth：基于Token的认证。

  ```
  通过指定--token-auth-file参数启用TokenAuth认证。
  TOKEN_FILE是一个CSV文件，每个用户在CSV中的表现形式为token、user、userid、group
  ```

  

- BootstrapToken：客户端的Token信息与服务端的Token相匹配，则认证通过，自动为节点颁发证书，这是一种引导Token的机制。

  ```
  key为Authorization，value为Bearer<TOKENS>
  
  指定--enable-bootstrap-token-auth参数启用BootstrapToken认证。
  
  ```

  

- RequestHeader：主要是用来与身份认证代理（eg, ingress , nginx）使用

- WebhookTokenAuth：webhoook钩子，将验证信息发送给远程的Webhook服务器进行认证

- Anonymous：匿名认证

- OIDC：基于OAuth 2.0协议的轻量级认证规范

- ServiceAccountAuth：服务账户令牌。ServiceAccountAuth是一种特殊的认证机制，其他认证机制都是处于Kubernetes集群外部而希望访问kube-apiserver组件，而ServiceAccountAuth认证是**从Pod资源内部访问kube-apiserver组件，提供给运行在Pod资源中的进程使用，它为Pod资源中的进程提供必要的身份证明，从而获取集群的信息**。

  ```
  --service-account-key-file 包含签名承载Token的PEM编码密钥的文件，用于验证Service Account Token
  -service-account-lookup
   ：用于验证Service Account Token是否存在于Etcd中
  ```

  

### 使用

```bash
# 查看集群支持的认证机制 查看集群证书
sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml
# - --client-ca-file=/etc/kubernetes/pki/ca.crt 启用ClientCA认证 使用 TLS/SSL 证书对客户端进行认证
# - --enable-bootstrap-token-auth=true 用于在集群引导过程中对节点进行身份验证。BootstrapToken

# 三个文件：CA 证书文件 客户端证书 客户端私钥
# 具体内容也可以看 cat ~/.kube/config

curl --cacert /etc/kubernetes/pki/ca.crt --cert /etc/kubernetes/pki/apiserver-kubelet-client.crt --key /etc/kubernetes/pki/apiserver-kubelet-client.key https://192.168.20.235:6443/api/v1/namespaces/kube-flannel/pods/kube-flannel-ds-5vmkr

```



## **授权**

当API Server被调用时，需要先进行用户认证，然后通过授权策略执行用户授权。

### 6种授权机制

kube-apiserver目前提供了6种授权机制，授权策略通过API Server启动参数`--authorization-mode`设置：

（1）AlwaysDeny：拒绝所有请求

（2）AlwaysAllow：允许接收所有请求

（3）**ABAC**（Attributed-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制

（4）**Webhook**：通过调用外部REST服务对用户进行授权

（5）**RBAC**：<u>Role-Based Access Control</u>，基于角色的访问控制

（6）**Node**：一种专用模式，用于对kubelet发起的请求进行访问控制

```bash
sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml #查看授权策略

# 如 --authorization-mode=RBAC,node
```



### RBAC授权模式

基于角色的访问控制。权限与角色相关联，形成了用户—角色—权限的授权模型。用户通过加入某些角色从而得到这些角色的操作权限，这极大地简化了权限管理。

![image-20240117110443564](img\image-20240117110443564.png)



### RBAC资源对象

RBAC有四个资源对象，分别是Role、ClusterRole、RoleBinding、ClusterRoleBinding



- **Role**

  一组权限的集合，在一个命名空间中，可以用其来定义一个角色，**只能对命名空间内的资源进行授权**。

  ```yaml
  #定义一个角色用来读取Pod的权限,允许读取核心API组的Pod资源
  apiVersion: rbac.authorization.k8s.io/v1
  kind: Role
  metadata:
    namespace: rbac
    name: pod-read
  rules:
  - apiGroups: [""]      #支持的API组列表
    resources: ["pods"]  #支持的资源对象列表
    resourceNames: []    #指定resource的名称
    verbs: ["get","watch","list"] #对资源对象的操作方法列表
  ```

  查看 `kubectl get roles -n rbac`

- **ClusterRole**

  具有和角色一致的命名空间资源的管理能力，还可用于授权 集群级别的资源、非资源型的路径、包含全部命名空间的资源

  ```yaml
  #定义一个集群角色可让用户访问任意secrets
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: secrets-clusterrole
  rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get","watch","list"]
  ```

  

- **RoleBinding**

  把一个角色绑定在一个目标subjects上，可以是User，Group，Service Account，使用RoleBinding为某个命名空间授权

  ```yaml
  #将在rbac命名空间中把pod-read角色授予用户es
  apiVersion: rbac.authorization.k8s.io/v1
  kind: RoleBinding
  metadata:
    name: pod-read-bind
    namespace: rbac
  subjects:
  - kind: User
    name: es
    apiGroup: rbac.authorization.k8s.io
  roleRef:
  - kind: Role
    name: pod-read
    apiGroup: rbac.authorizatioin.k8s.io
  ```

  ```yaml
  # kube-system命名空间中名为default的Service Account
  subjects:
  - kind: ServiceAccount
    name: default
    namespace: kube-system
  ```

  

- **ClusterRoleBinding**

  把一个角色绑定在一个目标上，集群角色绑定的角色只能是集群角色，使用ClusterRoleBinding为集群范围内授权。

  ```yaml
  #允许manager组的用户读取所有namaspace的secrets
  apiVersion: rabc.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: read-secret-global
  subjects:
  - kind: Group
    name: manager
    apiGroup: rabc.authorization.k8s.io
  ruleRef:
  - kind: ClusterRole
    name: secret-read
    apiGroup: rabc.authorization.k8s.io
  ```

  

## 用户

Kubernetes的两类用户

![image-20240117101544828](img\image-20240117101544828.png)

- **Normal Users** ：**普通用户**，一般由外部独立服务管理，前面介绍的认证机制（如BasicAuth、OIDC认证等）都属于普通用户，Kubernetes没有为这类用户设置用户对象
- **Service Account** ：**服务账户**，是由Kubernetes API Server管理的用户，它们被绑定到指定的命名空间，由Kubernetes API Server自动或手动创建。**Service Account是为了Pod资源中的进程方便与Kubernetes API Server进行通信而设置的。**

### **Service Account**

> **用户账户**: 除了 Service Account，Kubernetes 还支持用户账户，允许用户和其他实体进行身份认证。

服务账号，也是一种账号。**给运行在Pod里面的进程提供必要的身份证明**。这个ServiceAccount就相当于是拥有某个角色的账号，也就拥有了某些权限。

#### 内容

它们都通过mount命令的方式挂载在Pod的文件系统中。

- **Namespace**：指定了Pod所在的命名空间。`/var/run/secrets/kubernetes.io/serviceaccount/namespace`
- **CA**：kube-apiserver组件的CA公钥证书，是Pod中的进程对kube-apiserver进行验证的证书。`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
- **Token**：用作身份验证，通过kube-apiserver私钥签发（Sign）经过Base64编码的Bearer Token。`/var/run/secrets/kubernetes.io/serviceaccount/token`

**在每个Namespace下都有一个名为default的默认Service Account对象**，在这个ServiceAccount里面有一个名为Tokens的可以当做Volume被挂载到Pod里的Secret，当Pod启动时，这个Secret会自动被挂载到Pod的指定目录下，**用来协助完成Pod中的进程访问API Server时的身份鉴权**。

> **pod访问API Server时如何进行身份认证的？**
>
> https://kubernetes.io/zh-cn/docs/tasks/run-application/access-api-from-pod/
>
> https://kubernetes.io/zh-cn/docs/concepts/security/controlling-access/
>
> pod访问API Server服务时，在pod中是以service的方式访问名为`kubenetes`(https443端口)这个服务的，使用 TLS 进行加密通信。
>
> ```bash
> aiedge@xx-test-master235:~$ kubectl get svc
> NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
> kubernetes   ClusterIP   10.96.0.1        <none>        443/TCP   147d
> 
> ```
>
> ![Kubernetes API 请求处理步骤示意图](C:/Users/15313/Documents/k8s/controller/img/access-control-overview.svg)
>
> 在pod中，cd /run/secrets/kubernates.io/serviceaccount/有三个文件：
>
> 
>
> - 在为一个 pod 指定了 service account 后，kubernetes 会为该 service account 生成一个 JWT token，并使用 secret 将该 service account token 加载到 pod 上（**容器中`/var/run/secrets/kubernetes.io/serviceaccount/token`文件**）。pod 中的应用可以使用 service account token 来访问 api server。
>
>   token的生成：
>
>   由Kubernetes Controller进程kube-controller-manager **用API Server的私钥**（--service-account-private-zkey-file指定的私钥）**签名指定生成的一个JWT Secret**。
>
> - 通过HTTPS方式与API Server建立连接后，会用Pod里指定路径下的一个**CA证书（容器中`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`** **验证API Server发来的证书**，验证是否为CA证书签名的合法证书。
>
> - **Pod在调用API Server时，在Http Header中传递了一个Token字符串。**API Server收到Token后，采用自身私钥（service-accountkey-file指定，如果没有指定，则默认采用tls-private-key-file指定的参数）**对Token进行合法性验证**
>
> - 命名空间域 API 操作的默认命名空间放置每个容器中的 `/var/run/secrets/kubernetes.io/serviceaccount/namespace` 文件
>
> - **鉴权**：一旦 Token 被验证为有效，API Server 将使用其中的用户信息进行 RBAC 鉴权，以确定用户是否有执行请求操作的权限
>
> ![image-20231213100726801](C:/Users/15313/Documents/k8s/controller/img/image-20231213100726801.png)
>
> ```text
> 公钥加密，私钥解密。
> 私钥数字签名，公钥验证。
> 
> 密钥对：sa.key sa.pub  根证书：ca.crt etcd/ca.crt  私钥:ca.key 等
> 
> service Account密钥对 sa.key sa.pub
> 提供给 kube-controller-manager使用，kube-controller-manager通过 sa.key 对 token 进行签名,
> master 节点通过公钥 sa.pub 进行签名的验证 如 kube-proxy 是以 pod 形式运行的, 在 pod 中, 
> 直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了,
> 会直接使用token校验。
> ```

#### 使用

1. 创建ServiceAccount对象

   `kubectl create serviceaccount default:ingress-manager-sa `

2. 使用鉴权机制（如RBAC）为ServiceAccount对象授权

   ```yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRole
   metadata:
     creationTimestamp: null
     name: ingress-manager-role
   rules:
   - apiGroups:
     - ""
     resources:
     - services
     verbs:
     - list
     - watch
   - apiGroups:
     - networking.k8s.io
     resources:
     - ingresses
     verbs:
     - list
     - watch
     - create
     - update
     - delete
   
   ```

   ```yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRoleBinding
   metadata:
     creationTimestamp: null
     name: ingress-manager-rb
   roleRef:
     apiGroup: rbac.authorization.k8s.io
     kind: ClusterRole
     name: ingress-manager-role
   subjects:
   - kind: ServiceAccount
     name: ingress-manager-sa
     namespace: default
   
   ```

   

3. 在创建 Pod 期间将 ServiceAccount 对象指派给 Pod。

   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     creationTimestamp: null
     labels:
       app: ingress-manager
     name: ingress-manager
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: ingress-manager
     strategy: {}
     template:
       metadata:
         creationTimestamp: null
         labels:
           app: ingress-manager
       spec:
         serviceAccountName: ingress-manager-sa
         containers:
         - image: xiaox1958141/ingress-manager:v1.0.0
           name: ingress-manager
           resources: {}
   status: {}
   
   ```

   

4. 

   